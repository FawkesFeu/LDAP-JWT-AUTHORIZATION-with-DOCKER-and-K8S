apiVersion: v1
kind: ConfigMap
metadata:
  name: timescaledb-init
  namespace: ldap-jwt-app
  labels:
    app: timescaledb
data:
  init.sql: |
    -- Enable TimescaleDB extension
    CREATE EXTENSION IF NOT EXISTS timescaledb;
    
    -- Users table (for future non-LDAP users and metadata)
    CREATE TABLE users (
        id SERIAL PRIMARY KEY,
        username VARCHAR(255) UNIQUE NOT NULL,
        ldap_dn VARCHAR(500), -- LDAP Distinguished Name
        role VARCHAR(100) NOT NULL DEFAULT 'user',
        authorization_level INTEGER DEFAULT 1,
        is_active BOOLEAN DEFAULT true,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        last_login_at TIMESTAMP WITH TIME ZONE,
        login_count INTEGER DEFAULT 0,
        failed_attempts_count INTEGER DEFAULT 0,
        is_locked BOOLEAN DEFAULT false,
        lockout_until TIMESTAMP WITH TIME ZONE
    );
    
    -- Login attempts log (time-series data)
    CREATE TABLE login_attempts (
        id SERIAL PRIMARY KEY,
        username VARCHAR(255) NOT NULL,
        attempt_type VARCHAR(50) NOT NULL, -- 'success', 'failure', 'lockout'
        ip_address INET,
        user_agent TEXT,
        session_id VARCHAR(255),
        error_message TEXT,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
    );
    
    -- Convert to hypertable for time-series optimization
    SELECT create_hypertable('login_attempts', 'created_at');
    
    -- JWT sessions tracking
    CREATE TABLE jwt_sessions (
        id SERIAL PRIMARY KEY,
        token_id VARCHAR(255) UNIQUE NOT NULL,
        username VARCHAR(255) NOT NULL,
        token_type VARCHAR(50) NOT NULL, -- 'access', 'refresh'
        is_active BOOLEAN DEFAULT true,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
        revoked_at TIMESTAMP WITH TIME ZONE,
        ip_address INET,
        user_agent TEXT
    );
    
    -- User lockouts history
    CREATE TABLE user_lockouts (
        id SERIAL PRIMARY KEY,
        username VARCHAR(255) NOT NULL,
        lockout_reason VARCHAR(255) NOT NULL, -- 'failed_attempts', 'admin_lock', 'expired_password'
        failed_attempts_count INTEGER NOT NULL,
        lockout_start TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        lockout_end TIMESTAMP WITH TIME ZONE,
        is_active BOOLEAN DEFAULT true,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
    );
    
    -- Audit trail for admin actions
    CREATE TABLE admin_actions (
        id SERIAL PRIMARY KEY,
        admin_username VARCHAR(255) NOT NULL,
        target_username VARCHAR(255),
        action_type VARCHAR(100) NOT NULL, -- 'unlock_account', 'reset_password', 'change_role', 'create_user', 'delete_user'
        action_details JSONB,
        ip_address INET,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
    );
    
    -- Convert to hypertable for time-series optimization
    SELECT create_hypertable('admin_actions', 'created_at');
    
    -- Indexes for performance
    CREATE INDEX idx_login_attempts_username ON login_attempts(username);
    CREATE INDEX idx_login_attempts_created_at ON login_attempts(created_at DESC);
    CREATE INDEX idx_jwt_sessions_username ON jwt_sessions(username);
    CREATE INDEX idx_jwt_sessions_token_id ON jwt_sessions(token_id);
    CREATE INDEX idx_jwt_sessions_active ON jwt_sessions(is_active) WHERE is_active = true;
    CREATE INDEX idx_user_lockouts_username ON user_lockouts(username);
    CREATE INDEX idx_user_lockouts_active ON user_lockouts(is_active) WHERE is_active = true;
    CREATE INDEX idx_admin_actions_admin ON admin_actions(admin_username);
    CREATE INDEX idx_admin_actions_target ON admin_actions(target_username);
    
    -- Functions for automatic timestamp updates
    CREATE OR REPLACE FUNCTION update_updated_at_column()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
    END;
    $$ language 'plpgsql';
    
    -- Trigger for users table
    CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
        FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
    
    -- Function to get user's current lockout status
    CREATE OR REPLACE FUNCTION get_user_lockout_status(p_username VARCHAR)
    RETURNS TABLE(
        is_locked BOOLEAN,
        lockout_until TIMESTAMP WITH TIME ZONE,
        failed_attempts INTEGER
    ) AS $$
    BEGIN
        RETURN QUERY
        SELECT 
            u.is_locked,
            u.lockout_until,
            u.failed_attempts_count
        FROM users u
        WHERE u.username = p_username;
    END;
    $$ LANGUAGE plpgsql;
    
    -- Function to record login attempt
    CREATE OR REPLACE FUNCTION record_login_attempt(
        p_username VARCHAR,
        p_attempt_type VARCHAR,
        p_ip_address INET DEFAULT NULL,
        p_user_agent TEXT DEFAULT NULL,
        p_session_id VARCHAR DEFAULT NULL,
        p_error_message TEXT DEFAULT NULL
    ) RETURNS VOID AS $$
    BEGIN
        -- Insert login attempt
        INSERT INTO login_attempts (
            username, attempt_type, ip_address, user_agent, 
            session_id, error_message
        ) VALUES (
            p_username, p_attempt_type, p_ip_address, p_user_agent,
            p_session_id, p_error_message
        );
        
        -- Update user metadata
        IF p_attempt_type = 'success' THEN
            UPDATE users SET 
                last_login_at = NOW(),
                login_count = login_count + 1,
                failed_attempts_count = 0,
                is_locked = false,
                lockout_until = NULL
            WHERE username = p_username;
        ELSIF p_attempt_type = 'failure' THEN
            UPDATE users SET 
                failed_attempts_count = failed_attempts_count + 1
            WHERE username = p_username;
        END IF;
    END;
    $$ LANGUAGE plpgsql;
    
    -- Function to create/update user
    CREATE OR REPLACE FUNCTION upsert_user(
        p_username VARCHAR,
        p_ldap_dn VARCHAR DEFAULT NULL,
        p_role VARCHAR DEFAULT 'user',
        p_authorization_level INTEGER DEFAULT 1
    ) RETURNS INTEGER AS $$
    DECLARE
        user_id INTEGER;
    BEGIN
        INSERT INTO users (username, ldap_dn, role, authorization_level)
        VALUES (p_username, p_ldap_dn, p_role, p_authorization_level)
        ON CONFLICT (username) DO UPDATE SET
            ldap_dn = EXCLUDED.ldap_dn,
            role = EXCLUDED.role,
            authorization_level = EXCLUDED.authorization_level,
            updated_at = NOW()
        RETURNING id INTO user_id;
        
        RETURN user_id;
    END;
    $$ LANGUAGE plpgsql; 